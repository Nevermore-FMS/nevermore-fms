use crate::models::{Database, ThreadSafeDatabase};
use async_graphql::*;
use rand::RngCore;
use serde::{Deserialize, Serialize};

const CREATE_USER_TABLE: &'static str = "CREATE TABLE IF NOT EXISTS users
(
    username      TEXT PRIMARY KEY NOT NULL,
    full_name     TEXT             NOT NULL,
    password      TEXT             NOT NULL,
    pin           TEXT             NOT NULL
);";

#[derive(Clone, Debug)]
pub struct User {
    pub full_name: String,
    pub username: String,
    pub password: String,
    pub pin: String,
}

#[Object]
impl User {
    pub async fn id(&self) -> ID {
        base64::encode(format!("User:{}", self.username).as_bytes()).into()
    }

    pub async fn full_name(&self) -> String {
        self.full_name.clone()
    }

    pub async fn username(&self) -> String {
        self.username.clone()
    }
}

impl User {
    pub fn verify_password(&self, unverified_password: String) -> anyhow::Result<bool> {
        Ok(argon2::verify_encoded(
            self.password.as_str(),
            unverified_password.as_bytes(),
        )?)
    }

    pub fn verify_pin(&self, unverified_pin: String) -> anyhow::Result<bool> {
        Ok(argon2::verify_encoded(
            self.pin.as_str(),
            unverified_pin.as_bytes(),
        )?)
    }
}

#[derive(Clone, Deserialize, Serialize, InputObject)]
pub struct CreateUserParams {
    pub full_name: String,
    pub username: String,
    pub password: String,
    pub pin: String,
}

impl User {
    pub(crate) fn create_table(database: &Database) -> anyhow::Result<()> {
        database.conn.execute(CREATE_USER_TABLE, [])?;
        Ok(())
    }

    pub async fn create(
        database: ThreadSafeDatabase,
        params: CreateUserParams,
    ) -> anyhow::Result<()> {
        let database = database.lock().await;
        let config = argon2::Config::default();

        // Using salt generated by a secure rng
        let mut rng = rand::thread_rng();
        let mut salt = [0 as u8; 24];
        rng.try_fill_bytes(&mut salt)?;
        let password = argon2::hash_encoded(params.password.as_bytes(), &salt, &config)?;
        rng.try_fill_bytes(&mut salt)?;
        let pin = argon2::hash_encoded(params.pin.as_bytes(), &salt, &config)?;
        database.conn.execute(
            "INSERT INTO users (full_name, username, password, pin)
         VALUES (?1, ?2, ?3, ?4)",
            rusqlite::params![params.full_name, params.username, password, pin],
        )?;
        Ok(())
    }

    pub async fn delete(database: ThreadSafeDatabase, username: String) -> anyhow::Result<()> {
        let database = database.lock().await;
        database.conn.execute(
            "DELETE FROM users WHERE username = ?1",
            rusqlite::params![username],
        )?;
        Ok(())
    }

    pub async fn get(database: ThreadSafeDatabase, username: String) -> anyhow::Result<User> {
        let database = database.lock().await;
        let user = database.conn.query_row(
            "SELECT username, full_name, password, pin FROM users WHERE username = ?1",
            rusqlite::params![username],
            |row| {
                Ok(User {
                    username: row.get(0)?,
                    full_name: row.get(1)?,
                    password: row.get(2)?,
                    pin: row.get(3)?,
                })
            },
        )?;

        Ok(user)
    }

    pub async fn get_all_paginated(
        database: ThreadSafeDatabase,
        is_inverted: bool,
        limit: usize,
        after: Option<String>,
        before: Option<String>,
    ) -> anyhow::Result<(bool, bool, Vec<User>)> {
        if limit > 50 {
            return Err(anyhow::anyhow!("maximum limit is 50"));
        }
        let database = database.lock().await;

        let order_by = if is_inverted { "DESC" } else { "ASC" };

        let mut query_string = String::from("SELECT username, full_name, password, pin FROM users");
        let params = rusqlite::params![after.clone(), before.clone(), limit + 1];
        let mut _is_first_where = true;
        if after.is_some() || before.is_some() {
            query_string.push_str(" WHERE");
        }
        if after.is_some() {
            if _is_first_where {
                _is_first_where = false;
            } else {
                query_string.push_str(" AND");
            }
            query_string.push_str(" username > ?1");
        };

        if before.is_some() {
            if _is_first_where {
                _is_first_where = false;
            } else {
                query_string.push_str(" AND");
            }
            query_string.push_str(" username < ?2");
        };

        query_string.push_str(format!(" ORDER BY username {}", order_by).as_str());

        query_string.push_str(" LIMIT ?3");

        let mut stmt = database.conn.prepare(query_string.as_str())?;

        let users = stmt.query_map(params, |row| {
            Ok(User {
                username: row.get(0)?,
                full_name: row.get(1)?,
                password: row.get(2)?,
                pin: row.get(3)?,
            })
        })?;

        let users = users.map(|user| user.unwrap());

        let mut users: Vec<User> = users.collect();

        let mut has_next_page = false;
        if users.len() == limit + 1 {
            has_next_page = true;
            users.pop();
        }

        let has_prev_page = (after.is_some() && !is_inverted) || (before.is_some() && is_inverted);

        Ok((has_prev_page, has_next_page, users))
    }
}

mod tests {
    #[tokio::test]
    async fn test_users_model() -> anyhow::Result<()> {
        let db = super::super::Database::new(true, true, None).await?;

        // Insert Test Data
        super::User::create(
            db.clone(),
            super::CreateUserParams {
                full_name: "Test".to_string(),
                username: "test".to_string(),
                password: "test".to_string(),
                pin: "1234".to_string(),
            },
        )
        .await?;
        super::User::create(
            db.clone(),
            super::CreateUserParams {
                full_name: "Test".to_string(),
                username: "test1".to_string(),
                password: "test".to_string(),
                pin: "1234".to_string(),
            },
        )
        .await?;
        super::User::create(
            db.clone(),
            super::CreateUserParams {
                full_name: "Test".to_string(),
                username: "test2".to_string(),
                password: "test".to_string(),
                pin: "1234".to_string(),
            },
        )
        .await?;
        super::User::create(
            db.clone(),
            super::CreateUserParams {
                full_name: "Test".to_string(),
                username: "test3".to_string(),
                password: "test".to_string(),
                pin: "1234".to_string(),
            },
        )
        .await?;
        super::User::create(
            db.clone(),
            super::CreateUserParams {
                full_name: "Test".to_string(),
                username: "test4".to_string(),
                password: "test".to_string(),
                pin: "1234".to_string(),
            },
        )
        .await?;
        let (has_prev_page, has_next_page, workers) =
            super::User::get_all_paginated(db.clone(), false, 10, None, None).await?;
        assert_eq!(has_prev_page, false);
        assert_eq!(has_next_page, false);
        assert_eq!(workers.len(), 5);

        // Try Getting
        let user = super::User::get(db.clone(), "test".to_string()).await?;
        assert_eq!(user.full_name, "Test".to_string());
        assert_eq!(user.username, "test".to_string());
        assert!(!user.verify_password("not_password".to_string())?);
        assert!(user.verify_password("test".to_string())?);
        assert!(user.verify_pin("1234".to_string())?);
        let _ = super::User::get(db.clone(), "test1".to_string()).await?;

        // Try Delete One
        super::User::delete(db.clone(), "test".to_string()).await?;
        let (has_prev_page, has_next_page, users) =
            super::User::get_all_paginated(db.clone(), false, 10, None, None).await?;
        assert_eq!(has_prev_page, false);
        assert_eq!(has_next_page, false);
        assert_eq!(users.len(), 4);

        // Try Pagination
        let (has_prev_page, has_next_page, users) =
            super::User::get_all_paginated(db.clone(), false, 10, Some("test1".to_string()), None)
                .await?;
        assert_eq!(has_prev_page, true);
        assert_eq!(has_next_page, false);
        assert_eq!(users.len(), 3);

        let (has_prev_page, has_next_page, users) = super::User::get_all_paginated(
            db.clone(),
            false,
            10,
            Some("test1".to_string()),
            Some("test2".to_string()),
        )
        .await?;
        assert_eq!(has_prev_page, true);
        assert_eq!(has_next_page, false);
        assert_eq!(users.len(), 0);

        let (has_prev_page, has_next_page, users) =
            super::User::get_all_paginated(db.clone(), true, 10, None, Some("test4".to_string()))
                .await?;
        assert_eq!(has_prev_page, true);
        assert_eq!(has_next_page, false);
        assert_eq!(users.len(), 3);

        Ok(())
    }
}
