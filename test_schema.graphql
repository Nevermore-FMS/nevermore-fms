type Query {
  fieldState: FieldState

  driverStations: [DriverStation!]
  driverStation(
    teamNumber: Int
    allianceStation: AllianceStation
  ): DriverStation

  me: User!
  users: [User!]

  currentMatch: Match
  currentSchedule: Schedule
  schedules: [Schedule!]
}

type Mutation {
  fireFMSFault(code: String!, reason: String!): FMSFault
  clearFMSFault(id: ID!): Boolean!
  fireFMSWarning(code: String!, reason: String!): FMSWarning
  clearFMSWarning(id: ID!): Boolean!

  setDS(newDriverStations: [NewDsInput!]): [DriverStation]
  setDSEnabled(
    teamNumber: Int
    allianceStation: AllianceStation
    enabled: Boolean!
  ): DriverStation
  setDSEStopped(
    teamNumber: Int
    allianceStation: AllianceStation
    eStopped: Boolean!
  ): DriverStation
  removeDS(teamNumber: Int, allianceStation: AllianceStation): DriverStation
  clearAllDS: Boolean

  signIn(username: String!, password: String!): Token
  signOut: Boolean!

  startMatch: Boolean!
  stopMatch: Boolean!
  pauseMatch: Boolean!
  unPauseMatch: Boolean!
  commitMatch: Boolean!
  discardMatch: Boolean!

  setCurrentMatch(id: ID): Match

  createSchedule(newSchedule: ScheduleInput!): Schedule
  updateSchedule(id: ID!, newSchedule: ScheduleInput!): Schedule
  deleteSchedule(id: ID!): Boolean!
}

scalar IpCidr
scalar IpAddr

type FieldState {
  eventName: String!
  tournamentLevel: TournamentLevel!
  matchNumber: Int!
  playNumber: Int!
  timeLeft: DiffTimer
  udpOnline: Boolean!
  tcpOnline: Boolean!
  activeFMSFaults: [FMSFault!]
  activeFMSWarnings: [FMSWarning!]
}

enum TournamentLevel {
  Test
  Practice
  Qualification
  Playoff
}

type DiffTimer {
  startedAt: Int
  timeRemaining: Float!
}

type FMSFault {
  id: ID!
  code: String!
  name: String!
  reason: String!
}

type FMSWarning {
  id: ID!
  code: String!
  name: String!
  reason: String!
}

type DriverStation {
  teamNumber: Int!
  allianceStation: AllianceStation!
  mode: Mode!
  enabled: Boolean!
  eStopped: Boolean!
  expectedIp: IpCidr
  activeConnection: DriverStationConnection
  confirmedState: DriverStationConfirmedState
  logData: DriverStationLogData
  versions: [DriverStationVersion!]!
  logMessages: [String!]
}

type DriverStationConnection {
  id: ID!
  online: Boolean!
  ipAddress: IpAddr!
  sequenceNumber: Int!
  lastPacketReceivedAt: String!
}

type DriverStationConfirmedState {
  isEmergencyStopped: Boolean!
  robotCommunicationsActive: Boolean!
  canPingRadio: Boolean!
  canPingRio: Boolean!
  isEnabled: Boolean!
  mode: Mode!
  teamNumber: Int!
  batteryVoltage: Float!
}

type DriverStationLogData {
  tripTime: Int!
  lostPackets: Int!
  brownout: Boolean!
  watchdog: Boolean!
  dsTeleop: Boolean!
  dsAuto: Boolean!
  dsDisable: Boolean!
  robotTeleop: Boolean!
  robotAuto: Boolean!
  robotDisable: Boolean!
  canUtilization: Int!
  signal: Int!
  bandwidth: Float!
}

type DriverStationVersion {
  versionType: VersionType!
  version: Version!
}

type User {
  id: ID!
  name: String!
  username: String!
}

enum VersionType {
  WPILib
  RoboRIO
  DS
  PDP
  PCM
  CANJag
  CANTalon
  ThirdParty
}

type Version {
  status: String!
  versionString: String!
}

enum AllianceStation {
  Red1
  Red2
  Red3
  Blue1
  Blue2
  Blue3
}

enum Mode {
  TeleOp
  Test
  Autonomous
}

interface Match {
  id: ID!
  scheduledMatch: ScheduledMatch!
  playNumber: Int!
  redScore: Int!
  blueScore: Int!
  done: Boolean!
  success: Boolean!
}

type Match2023 implements Match {
  id: ID!
  scheduledMatch: ScheduledMatch!
  playNumber: Int!
  redScore: Int!
  blueScore: Int!
  done: Boolean!
  success: Boolean!
  # Include extra fields for 2023 game scoring
}

type ScheduledMatch {
  id: ID!
  matchNumber: Int!
  fromSchedule: Schedule!
  matches: [Match!]!
  red1: Int
  red2: Int
  red3: Int
  blue1: Int
  blue2: Int
  blue3: Int
  scheduledStartTime: Int!
  notes: String
}

type Schedule {
  id: ID!
  name: String!
  notes: String
  scheduledStartTime: Int!
  tournamentLevel: TournamentLevel!
  scheduledMatches: [ScheduledMatch!]!
}

input DriverStationInput {
  teamNumber: Int!
  allianceStation: AllianceStation!
  expectedIp: IpCidr
}

type Token {
  expiresAt: Int!
  scope: [String!]!
  tokenValue: String!
}

input ScheduleInput {
  name: String!
  notes: String!
  blocks: [ScheduleBlocksInput!]!
}

input ScheduleBlocksInput {
  startTime: Int!
  cycleTime: Int!
  numMatches: Int!
}
type Query {
  fieldState: FieldState

  driverStations: [DriverStation!]
  driverStation(
    teamNumber: Int
    allianceStation: AllianceStation
  ): DriverStation

  me: User!
  users: [User!]

  currentMatch: Match
  currentSchedule: Schedule
  schedules: [Schedule!]
}

type Mutation {
  fireFMSFault(code: String!, reason: String!): FMSFault
  clearFMSFault(id: ID!): Boolean!
  fireFMSWarning(code: String!, reason: String!): FMSWarning
  clearFMSWarning(id: ID!): Boolean!

  setDS(newDriverStations: [NewDsInput!]): [DriverStation]
  setDSEnabled(
    teamNumber: Int
    allianceStation: AllianceStation
    enabled: Boolean!
  ): DriverStation
  setDSEStopped(
    teamNumber: Int
    allianceStation: AllianceStation
    eStopped: Boolean!
  ): DriverStation
  removeDS(teamNumber: Int, allianceStation: AllianceStation): DriverStation
  clearAllDS: Boolean

  signIn(username: String!, password: String!): Token
  signOut: Boolean!

  startMatch: Boolean!
  stopMatch: Boolean!
  pauseMatch: Boolean!
  unPauseMatch: Boolean!
  commitMatch: Boolean!
  discardMatch: Boolean!

  setCurrentMatch(id: ID): Match

  createSchedule(newSchedule: ScheduleInput!): Schedule
  updateSchedule(id: ID!, newSchedule: ScheduleInput!): Schedule
  deleteSchedule(id: ID!): Boolean!
}

scalar IpCidr
scalar IpAddr

type FieldState {
  eventName: String!
  tournamentLevel: TournamentLevel!
  matchNumber: Int!
  playNumber: Int!
  timeLeft: DiffTimer
  udpOnline: Boolean!
  tcpOnline: Boolean!
  activeFMSFaults: [FMSFault!]
  activeFMSWarnings: [FMSWarning!]
}

enum TournamentLevel {
  Test
  Practice
  Qualification
  Playoff
}

type DiffTimer {
  startedAt: Int
  timeRemaining: Float!
}

type FMSFault {
  id: ID!
  code: String!
  name: String!
  reason: String!
}

type FMSWarning {
  id: ID!
  code: String!
  name: String!
  reason: String!
}

type DriverStation {
  teamNumber: Int!
  allianceStation: AllianceStation!
  mode: Mode!
  enabled: Boolean!
  eStopped: Boolean!
  expectedIp: IpCidr
  activeConnection: DriverStationConnection
  confirmedState: DriverStationConfirmedState
  logData: DriverStationLogData
  versions: [DriverStationVersion!]!
  logMessages: [String!]
}

type DriverStationConnection {
  id: ID!
  online: Boolean!
  ipAddress: IpAddr!
  sequenceNumber: Int!
  lastPacketReceivedAt: String!
}

type DriverStationConfirmedState {
  isEmergencyStopped: Boolean!
  robotCommunicationsActive: Boolean!
  canPingRadio: Boolean!
  canPingRio: Boolean!
  isEnabled: Boolean!
  mode: Mode!
  teamNumber: Int!
  batteryVoltage: Float!
}

type DriverStationLogData {
  tripTime: Int!
  lostPackets: Int!
  brownout: Boolean!
  watchdog: Boolean!
  dsTeleop: Boolean!
  dsAuto: Boolean!
  dsDisable: Boolean!
  robotTeleop: Boolean!
  robotAuto: Boolean!
  robotDisable: Boolean!
  canUtilization: Int!
  signal: Int!
  bandwidth: Float!
}

type DriverStationVersion {
  versionType: VersionType!
  version: Version!
}

type User {
  id: ID!
  name: String!
  username: String!
}

enum VersionType {
  WPILib
  RoboRIO
  DS
  PDP
  PCM
  CANJag
  CANTalon
  ThirdParty
}

type Version {
  status: String!
  versionString: String!
}

enum AllianceStation {
  Red1
  Red2
  Red3
  Blue1
  Blue2
  Blue3
}

enum Mode {
  TeleOp
  Test
  Autonomous
}

interface Match {
  id: ID!
  scheduledMatch: ScheduledMatch!
  playNumber: Int!
  redScore: Int!
  blueScore: Int!
  done: Boolean!
  success: Boolean!
}

type Match2023 implements Match {
  id: ID!
  scheduledMatch: ScheduledMatch!
  playNumber: Int!
  redScore: Int!
  blueScore: Int!
  done: Boolean!
  success: Boolean!
  # Include extra fields for 2023 game scoring
}

type ScheduledMatch {
  id: ID!
  matchNumber: Int!
  fromSchedule: Schedule!
  matches: [Match!]!
  red1: Int
  red2: Int
  red3: Int
  blue1: Int
  blue2: Int
  blue3: Int
  scheduledStartTime: Int!
  notes: String
}

type Schedule {
  id: ID!
  name: String!
  notes: String
  scheduledStartTime: Int!
  tournamentLevel: TournamentLevel!
  scheduledMatches: [ScheduledMatch!]!
}

input DriverStationInput {
  teamNumber: Int!
  allianceStation: AllianceStation!
  expectedIp: IpCidr
}

type Token {
  expiresAt: Int!
  scope: [String!]!
  tokenValue: String!
}

input ScheduleInput {
  name: String!
  notes: String!
  blocks: [ScheduleBlocksInput!]!
}

input ScheduleBlocksInput {
  startTime: Int!
  cycleTime: Int!
  numMatches: Int!
}
